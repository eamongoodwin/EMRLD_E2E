<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Keyforge - Secure Messenger</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="icon" href="/logo_ani01.svg" type="image/svg+xml">
    <meta name="description" content="Quantum-Grade Encryption. Secure end-to-end encrypted messaging with EMRLD Chain technology.">
    <meta name="keywords" content="encryption, secure messaging, quantum, EMRLD, end-to-end">
</head>
<body>
    <div class="app">
        <div class="container">
            <!-- Initial Verification Screen -->
            <div id="verificationScreen">
                <div class="header">
                    <div class="flex-center-mb">
                        <img src="/logo_ani01.svg" alt="Keyforge Logo" class="logo glow-img" onerror="this.style.display='none';">
                        <img src="/keyforge.svg" alt="Keyforge" class="img-lg glow-img" onerror="this.innerHTML='<h1 class=\'keyforge-logo-fallback\'>Keyforge</h1>';">
                    </div>
                    <p class="subtitle">Secure Access Verification</p>
                </div>

                <div class="card card-centered">
                    <img src="/shield.svg" alt="Shield" class="img-md img-inline">
                    <h3 class="h3-center">Security Check</h3>
                    <p class="text-center text-gray mb-6">
                        Please complete the security verification to access Keyforge secure messaging.
                    </p>

                    <!-- Turnstile widget removed for testing -->

                    <!-- Invisible turnstile widget for token minting -->

                    <div id="verificationStatus" aria-live="polite"></div>
                </div>
            </div>

            <!-- Setup Screen -->
            <div id="setupScreen" class="hidden">
                <div class="header">
                    <div class="flex-center-mb">
                        <img src="/logo_ani01.svg" alt="Keyforge Logo" class="logo glow-img" onerror="this.style.display='none';">
                        <img src="/keyforge.svg" alt="Keyforge" class="img-lg glow-img" onerror="this.innerHTML='<h1 class=\'keyforge-logo-fallback\'>Keyforge</h1>';">
                    </div>
                    <p class="subtitle">Future-proof messaging.</p>
                </div>
                
                <div class="info-banner">
                    <strong>Enhanced Multi-Round Layered Diffusion (EMRLD) Chain</strong><br>
                    Resilient â€¢ Layered â€¢ Quantum-Ready
                </div>
                
                <div class="tabs" role="tablist" aria-label="Room actions">
                    <button id="createTabBtn" class="tab active" role="tab" aria-selected="true" aria-controls="createCard"
                            onclick="switchTab('create')">
                        <span>Create Room</span>
                    </button>
                    <button id="joinTabBtn" class="tab" role="tab" aria-selected="false" aria-controls="joinCard"
                            onclick="switchTab('join')">
                        <span>Join Room</span>
                    </button>
                </div>
                
                <div class="grid">
                  <div class="card" id="createCard" role="tabpanel" aria-labelledby="createTabBtn">
                    <form id="createTab" onsubmit="event.preventDefault(); createRoom();">
                      <h3>Start a Secure Chat</h3>
                      <div class="form-group">
                        <label for="createRoomName">Room Name</label>
                        <input type="text" id="createRoomName" placeholder="My Chat Room" maxlength="50" required>
                      </div>
                      <div class="form-group">
                        <label for="createPassword">Room Password</label>
                        <input type="password" id="createPassword" placeholder="Room Password (min length: 6)" minlength="6" autocomplete="new-password" required>
                      </div>
                      <div class="form-group">
                        <label for="createUserName">Your Name</label>
                        <input type="text" id="createUserName" placeholder="Your Name" maxlength="30" required>
                      </div>

                      <button id="createBtn" class="btn btn-primary" type="submit">
                        Create Secure Room
                      </button>
                    </form>
                  </div>

                  <!-- NEW: Join card lives in the same grid and has the same styling -->
                  <div class="card hidden" id="joinCard" role="tabpanel" aria-labelledby="joinTabBtn">
                    <form id="joinTab" onsubmit="event.preventDefault(); joinRoom();">
                      <h3>Join Existing Room</h3>
                      <div class="form-group">
                        <label for="joinRoomId">Room ID</label>
                        <input type="text" id="joinRoomId" placeholder="emerald_ab12CD34"
                               pattern="emerald_[A-Za-z0-9]{8}"
                               title='Format: "emerald_" followed by 8 letters or numbers'
                               required>
                      </div>
                      <div class="form-group">
                        <label for="joinPassword">Room Password</label>
                        <input type="password" id="joinPassword" placeholder="Room password" minlength="6" autocomplete="current-password" required>
                      </div>
                      <div class="form-group">
                        <label for="joinUserName">Your Name</label>
                        <input type="text" id="joinUserName" placeholder="Your Name" maxlength="30" required>
                      </div>

                      <button id="joinBtn" class="btn btn-success" type="submit">
                        Join Secure Chat
                      </button>
                    </form>
                  </div>

                  <div class="card">
                        <div class="features">
                            <img src="/shield.svg" alt="Shield" class="img-md img-inline">
                            <h3>Keyforge Security</h3>
                            <ul>
                                <li>8-Pass AES-256-CBC multi-round encryption</li>
                                <li>2048-bit PBKDF2 key derivation (1.6M iterations)</li>
                                <li>QKD with privacy amplification</li>
                                <li>XOR masking with quantum-inspired keys</li>
                                <li>NIST PQC-aligned hybrid architecture</li>
                            </ul>
                        </div>
                    </div>
                </div>
                
                <div id="setupStatus" aria-live="polite"></div>
            </div>
        
            <!-- Main Chat Interface -->
            <div id="chatScreen" class="hidden">
                <div class="chat-header">
                    <div class="flex-align-center">
                        <img src="/logo_ani01.svg" alt="Keyforge" class="logo" onerror="this.style.display='none';">
                        <img src="/keyforge.svg" alt="Keyforge" class="chat-header-logo glow-img" onerror="this.innerHTML='<h1 class=\'keyforge-logo-fallback\'>Keyforge</h1>'">
                        <div class="ml-3">
                            <h1 id="roomTitle" class="chat-room-title">room title</h1>
                        </div>
                    </div>
                    <div class="badge">Live</div>
                </div>
                
                <div class="room-info">
                    <div class="room-details">
                        <div id="roomDetails">
                            Room ID: <span id="roomIdSpan" onclick="copyRoomId()" class="room-id-clickable" title="Click to copy Room ID">emerald_demo</span> â€¢ User: Placeholder
                        </div>
                    </div>
                    <div class="status-indicator">
                        <div class="pulse"></div>
                        <span>Secured</span>
                    </div>
                </div>
                
                <div class="messages" id="messagesContainer">
                    <!-- Messages will be dynamically loaded here -->
                    <div class="message">
                        <div class="message-header">
                            <span>Welcome Bot</span>
                            <div>
                                <span class="encryption-badge">EMRLD</span>
                                <span class="text-muted">
                                    <script>document.write(new Date().toLocaleTimeString())</script>
                                </span>
                            </div>
                        </div>
                        <div class="message-content">
                            Welcome to Keyforge! Your messages are protected by the EMRLD Chain hybrid encryption framework. 
                            Each message undergoes 8-pass AES-256-CBC encryption with simulated QKD key masking for quantum resistance.
                        </div>
                    </div>
                </div>

                <!-- keep your messagesContainer exactly as you have it -->

                <div class="input-area">
                <!-- Full-width input at the top -->
                 <div class="input-wrapper">
                 <input
                      type="text"
                      id="messageInput"
                     placeholder="Type a secure message..."
                     maxlength="1000"
                     onkeypress="if(event.key==='Enter' && !event.shiftKey) { event.preventDefault(); sendMessage(); }"
                     autocomplete="off"
                     aria-label="Type a secure message"
                    />
                 </div>

                <!-- Buttons live together on one row -->
                <div class="composer-actions">
                  <button class="btn btn-success" onclick="sendMessage()" title="Send Message">Send</button>
                  <button class="btn btn-secondary" onclick="refreshMessages()" title="Refresh Messages">Refresh</button>
                 <button class="btn btn-secondary" onclick="shareInvite()" title="Share Invite Link">Share</button>
                </div>

                 <!-- Stays at the bottom, full width -->
                <div class="decrypt-area">
                  <strong>EMRLD Chain</strong>
                  <p>All rights reserved.</p>
                 </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Application State
        let currentRoom = null;
        let currentUser = null;
        let messagePolling = null;
        let isLoading = false;
        let renderedIds = new Set();
        let messageCache = new Map();
        let lastMessageId = null;
        let optimisticMessages = new Map();
        let isVerified = false;
        let savedTurnstileToken = null;

        // Initialize application
        function initializeApp() {
            console.log('Keyforge initialized');

            // Skip verification for testing - go directly to main interface
            showMainInterface();

            // Add loading states to buttons
            document.querySelectorAll('button').forEach(btn => {
                btn.addEventListener('click', function() {
                    if (!this.disabled) {
                        this.classList.add('loading');
                        setTimeout(() => this.classList.remove('loading'), 1000);
                    }
                });
            });
        }

        // Show verification screen
        function showVerificationScreen() {
            document.getElementById('verificationScreen').classList.remove('hidden');
            document.getElementById('setupScreen').classList.add('hidden');
            document.getElementById('chatScreen').classList.add('hidden');
        }

        // Show main interface after verification
        function showMainInterface() {
            // Hide verification screen but keep widget accessible by making it invisible instead of hidden
            const verificationScreen = document.getElementById('verificationScreen');
            verificationScreen.style.position = 'absolute';
            verificationScreen.style.left = '-9999px';
            verificationScreen.style.visibility = 'hidden';

            document.getElementById('setupScreen').classList.remove('hidden');
            document.getElementById('chatScreen').classList.add('hidden');
            console.log('Showing main interface, widget should still be accessible');

            // Handle URL-based tab persistence and room prefilling
            const qs = new URLSearchParams(location.search);
            if (location.hash === '#join' || qs.get('tab') === 'join') {
                switchTab('join');
            }
            const room = qs.get('room');
            if (room) {
                switchTab('join');
                document.getElementById('joinRoomId').value = room;
            }
        }

        // Tab Management
        function switchTab(tab) {
            // tab button state
            const tabs = document.querySelectorAll('.tab');
            tabs.forEach(t => {
                t.classList.remove('active');
                t.setAttribute('aria-selected', 'false');
            });
            const activeTab = tabs[tab === 'create' ? 0 : 1];
            activeTab.classList.add('active');
            activeTab.setAttribute('aria-selected', 'true');

            // show/hide whole cards so the styling stays consistent
            const createCard = document.getElementById('createCard');
            const joinCard   = document.getElementById('joinCard');
            if (tab === 'create') {
                createCard.classList.remove('hidden');
                joinCard.classList.add('hidden');
                document.getElementById('createRoomName')?.focus();
            } else {
                createCard.classList.add('hidden');
                joinCard.classList.remove('hidden');
                document.getElementById('joinRoomId')?.focus();
            }
        }

        // Verification disabled for testing - always allow actions
        function requireVerification(actionName) {
            console.log(`requireVerification called for ${actionName} - bypassed for testing`);
            return true; // Always allow actions when testing
        }

        // Dummy token generation for testing (no Turnstile)
        async function mintToken(action = '') {
            console.log(`Generating dummy token for action: ${action}`);
            // Return a dummy token for testing
            return 'DUMMY_TOKEN_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        }

        // Room Creation
        async function createRoom() {
            if (isLoading || !requireVerification('create room')) return;
            isLoading = true;

            const roomName = document.getElementById('createRoomName').value.trim();
            const password = document.getElementById('createPassword').value;
            const userName = document.getElementById('createUserName').value.trim();

            if (!roomName || !password || !userName) {
                showStatus('Please fill in all fields', 'error');
                isLoading = false;
                return;
            }
            if (password.length < 6) {
                showStatus('Password must be at least 6 characters for security', 'error');
                isLoading = false;
                return;
            }


            try {
                // Get fresh Turnstile token using invisible widget
                console.log('Getting fresh Turnstile token for room creation...');
                const token = await mintToken('create_room');

                if (!token) {
                    isLoading = false;
                    return;
                }

                // Create room
                console.log('Creating room with fresh token...');
                const createRes = await fetch('/api/room/create', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'cf-turnstile-response': token
                    },
                    body: JSON.stringify({
                        roomName,
                        password,
                        token,
                        'cf-turnstile-response': token
                    })
                });
                const createJson = await createRes.json();
                console.log('Create room response:', createJson);
                if (!createJson.success) {
                    showStatus(`Failed to create room: ${createJson.error}`, 'error');
                    return;
                }

                const roomId = createJson.roomId;
                console.log('Room created successfully:', roomId);
                // Prefill the join box for convenience
                document.getElementById('joinRoomId').value = roomId;

                // 3) Immediately join the room we just created
                // Note: We can reuse the same token since Turnstile allows one verification per widget per session
                console.log('Auto-joining room...');
                const joinRes = await fetch('/api/room/join', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'cf-turnstile-response': token
                    },
                    body: JSON.stringify({
                        roomId,
                        password,
                        token,
                        'cf-turnstile-response': token
                    })
                });
                const joinJson = await joinRes.json();
                console.log('Join room response:', joinJson);
                if (!joinJson.success) {
                    showStatus(`Created but could not join: ${joinJson.error}`, 'error');
                    return;
                }

                // 4) Enter chat
                console.log('Entering chat...');
                currentRoom = { id: roomId, name: joinJson.room.name || roomName, password };
                currentUser = userName;
                console.log('Current room set:', currentRoom);
                console.log('Current user set:', currentUser);
                enterChat();
                showStatus(`Your secure chat room has been created. Share this Room ID and password to invite others.: ${roomId}`, 'success');

            } catch (e) {
                showStatus(`Network error: ${e.message}`, 'error');
            } finally {
                isLoading = false;
            }
        }

        // Room Joining
        async function joinRoom() {
            if (isLoading || !requireVerification('join room')) return;
            isLoading = true;

            const roomId = document.getElementById('joinRoomId').value.trim();
            const password = document.getElementById('joinPassword').value;
            const userName = document.getElementById('joinUserName').value.trim();


            // Validation
            if (!roomId || !password || !userName) {
                showStatus('All fields are required', 'error');
                isLoading = false;
                return;
            }
            
            if (!roomId.startsWith('emerald_')) {
                showStatus('Invalid room ID format. Should start with "emerald_"', 'error');
                isLoading = false;
                return;
            }
            
            try {
                // Get fresh Turnstile token using invisible widget
                console.log('Getting fresh Turnstile token for room join...');
                const token = await mintToken('join_room');

                if (!token) {
                    isLoading = false;
                    return;
                }

                // Join room
                console.log('Joining room with fresh token...');
                const response = await fetch('/api/room/join', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'cf-turnstile-response': token
                    },
                    body: JSON.stringify({
                        roomId,
                        password,
                        token,
                        'cf-turnstile-response': token
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    currentRoom = { id: roomId, name: result.room.name, password };
                    currentUser = userName;
                    enterChat();
                    showStatus('Welcome to Keyforge!', 'success');

                } else {
                    showStatus(`Access denied: ${result.error}`, 'error');
                }
            } catch (error) {
                showStatus(`Connection error: ${error.message}`, 'error');
            } finally {
                isLoading = false;
            }
        }

        // Enter Chat Interface with proper state management
        function enterChat() {
            console.log('enterChat() called');
            console.log('currentRoom:', currentRoom);
            console.log('currentUser:', currentUser);

            // Reset state for new room/view (security & stability)
            try {
                renderedIds.clear();
                messageCache.clear();
                optimisticMessages.clear();
            } catch {}
            if (messagePolling) { clearInterval(messagePolling); messagePolling = null; }
            lastMessageId = null;

            console.log('Switching screens...');
            const setupScreen = document.getElementById('setupScreen');
            const chatScreen = document.getElementById('chatScreen');
            console.log('setupScreen element:', setupScreen);
            console.log('chatScreen element:', chatScreen);

            setupScreen.classList.add('hidden');
            chatScreen.classList.remove('hidden');
            console.log('Screen switch complete');

            document.getElementById('roomTitle').textContent = currentRoom.name || 'Room';
            document.getElementById('roomDetails').innerHTML =
                `Room: <span id="roomIdSpan" onclick="copyRoomId()" class="room-id-clickable" title="Click to copy Room ID">${currentRoom.id}</span> â€¢ User: ${currentUser} â€¢ Invite with Room ID and password`;

            const box = document.getElementById('messagesContainer');
            box.innerHTML = '';

            console.log('Starting message loading...');
            // Kick off fresh load + polling
            loadMessages();
            messagePolling = setInterval(loadMessages, 3000);
            console.log('enterChat() complete');
        }

        // Copy Room ID to clipboard
        async function copyRoomId() {
            if (!currentRoom) return;

            try {
                await navigator.clipboard.writeText(currentRoom.id);

                // Show visual feedback
                const roomSpan = document.getElementById('roomIdSpan');
                const originalText = roomSpan.textContent;

                roomSpan.textContent = 'Copied!';
                roomSpan.style.color = '#28a745';

                // Reset after 1 second
                setTimeout(() => {
                    roomSpan.textContent = originalText;
                    roomSpan.style.color = '#1e3c72';
                }, 1000);

            } catch (err) {
                // Fallback for older browsers
                const textArea = document.createElement('textarea');
                textArea.value = currentRoom.id;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);

                // Show feedback
                const roomSpan = document.getElementById('roomIdSpan');
                const originalText = roomSpan.textContent;
                roomSpan.textContent = 'Copied!';

                setTimeout(() => {
                    roomSpan.textContent = originalText;
                }, 1000);
            }
        }

        // Share / copy an invite link that opens the Join tab with the room prefilled
        async function shareInvite() {
            if (!currentRoom) { showStatus('Create or join a room first', 'error'); return; }
            const url = new URL(location.origin + location.pathname);
            url.searchParams.set('tab', 'join');
            url.searchParams.set('room', currentRoom.id);
            url.hash = 'join';
            const link = url.toString();

            try {
                if (navigator.share) {
                    await navigator.share({ title: 'Join my Keyforge room', url: link });
                    return;
                }
                await navigator.clipboard.writeText(link);
                showStatus('Invite link copied to clipboard', 'success');
            } catch (_e) {
                try {
                    await navigator.clipboard.writeText(link);
                    showStatus('Invite link copied to clipboard', 'success');
                } catch {
                    showStatus('Unable to copy invite link', 'error');
                }
            }
        }
        
        // Message Sending with optimistic updates
        async function sendMessage() {
            const messageText = document.getElementById('messageInput').value.trim();
            if (!messageText || isLoading) return;
            
            isLoading = true;
            const inputField = document.getElementById('messageInput');
            const originalValue = inputField.value;
            inputField.value = '';
            inputField.disabled = true;
            
            // Generate optimistic message ID
            const optimisticId = `${Date.now()}-${currentUser}-optimistic`;
            const container = document.getElementById('messagesContainer');
            
            // Add optimistic message immediately
            const optimisticMsg = {
                timestamp: Date.now(),
                sender: currentUser,
                encryptedData: 'optimistic',
                keyData: 'optimistic'
            };
            
            // Create optimistic message element
            const messageDiv = document.createElement('div');
            messageDiv.className = `message own optimistic-message`;
            messageDiv.dataset.msgId = optimisticId;
            messageDiv.style.opacity = '0.7';
            messageDiv.innerHTML = `
                <div class="message-header">
                    <span>${escapeHtml(currentUser)}</span>
                    <div>
                        <span class="encryption-badge sending">SENDING</span>
                        <span class="text-muted">
                            ${new Date().toLocaleTimeString()}
                        </span>
                    </div>
                </div>
                <div class="message-content">${escapeHtml(messageText)}</div>
            `;
            container.appendChild(messageDiv);
            container.scrollTop = container.scrollHeight;
            
            optimisticMessages.set(optimisticId, messageDiv);
            
            try {
                // Get fresh Turnstile token
                const token = await mintToken('send_message');
                if (!token) {
                    throw new Error('Failed to get security token');
                }

                const response = await fetch('/api/message/send', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'cf-turnstile-response': token
                    },
                    body: JSON.stringify({
                        roomId: currentRoom.id,
                        message: messageText,
                        senderName: currentUser
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    // Update optimistic message to confirmed state
                    messageDiv.style.opacity = '1';
                    const badge = messageDiv.querySelector('.encryption-badge');
                    badge.textContent = 'EMRLD';
                    badge.style.background = '#10b981';
                    
                    // Load new messages to get the real encrypted version
                    setTimeout(() => loadMessages(), 500);
                } else {
                    // Remove optimistic message and restore input
                    messageDiv.remove();
                    optimisticMessages.delete(optimisticId);
                    inputField.value = originalValue;
                    alert(`Failed to send: ${result.error}`);
                }
            } catch (error) {
                // Remove optimistic message and restore input
                messageDiv.remove();
                optimisticMessages.delete(optimisticId);
                inputField.value = originalValue;
                alert(`Network error: ${error.message}`);
            } finally {
                inputField.disabled = false;
                isLoading = false;
            }
        }

        // Message Loading with deduplication and error recovery
        async function loadMessages(retries = 3) {
            if (!currentRoom) return;
            
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 10000); // 10s timeout
                
                const response = await fetch(`/api/room/${currentRoom.id}/messages`, {
                    signal: controller.signal
                });
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const result = await response.json();
                
                if (result.success) {
                    await displayMessagesIncremental(result.messages);
                    // Reset connection health indicator
                    updateConnectionStatus(true);
                } else {
                    throw new Error(result.error || 'Unknown server error');
                }
            } catch (error) {
                console.error('Failed to load messages:', error);
                updateConnectionStatus(false);
                
                // Exponential backoff retry for network errors
                if (retries > 0 && (error.name === 'AbortError' || error.message.includes('fetch'))) {
                    const delay = Math.pow(2, 3 - retries) * 1000; // 1s, 2s, 4s
                    setTimeout(() => loadMessages(retries - 1), delay);
                }
            }
        }
        
        // Connection status indicator
        function updateConnectionStatus(isConnected) {
            const statusElement = document.querySelector('.status-indicator span');
            if (!statusElement) return;
            
            if (isConnected) {
                statusElement.textContent = 'E2E';
                statusElement.style.color = '#10b981';
            } else {
                statusElement.textContent = 'âš ï¸ Reconnecting...';
                statusElement.style.color = '#f59e0b';
            }
        }

        // Incremental Message Display (prevents flashing)
        async function displayMessagesIncremental(messages) {
            const container = document.getElementById('messagesContainer');
            
            // Create content-based message ID for proper deduplication
            const getContentId = (msg, decryptedText = null) => {
                // Use sender + decrypted content + approximate time for deduplication
                const timeWindow = Math.floor(msg.timestamp / 5000) * 5000; // 5s window
                return `${msg.sender}-${decryptedText || 'encrypted'}-${timeWindow}`;
            };
            
            // Track which messages are new
            const newMessages = [];
            for (const msg of messages) {
                try {
                    // Try to decrypt to get content-based ID
                    const decrypted = await decryptMessage(msg.encryptedData, msg.keyData, currentRoom.id);
                    const contentId = getContentId(msg, decrypted.success ? decrypted.message : null);
                    
                    if (!renderedIds.has(contentId)) {
                        renderedIds.add(contentId);
                        newMessages.push({ ...msg, contentId, decrypted });
                    }
                } catch (error) {
                    // Fallback to timestamp-based ID for undecryptable messages
                    const fallbackId = `${msg.timestamp}-${msg.sender}-${msg.encryptedData.substring(0, 20)}`;
                    if (!renderedIds.has(fallbackId)) {
                        renderedIds.add(fallbackId);
                        newMessages.push({ ...msg, contentId: fallbackId, decrypted: { success: false } });
                    }
                }
            }
            
            // Remove any optimistic messages that match the real messages
            for (const msg of newMessages) {
                // Remove optimistic messages for the same content
                const optimisticToRemove = [];
                for (const [optimisticId, element] of optimisticMessages.entries()) {
                    const optimisticContent = element.querySelector('.message-content')?.textContent;
                    const realContent = msg.decrypted.success ? msg.decrypted.message : null;
                    
                    if (optimisticContent && realContent && optimisticContent.trim() === realContent.trim() && 
                        element.querySelector('.message-header span')?.textContent === msg.sender) {
                        optimisticToRemove.push(optimisticId);
                        element.remove();
                    }
                }
                optimisticToRemove.forEach(id => optimisticMessages.delete(id));
            }
            
            // Only render new messages
            for (const msg of newMessages) {
                await renderSingleMessage(msg, container, msg.decrypted);
            }
            
            // Auto-scroll only if user is near bottom (UX best practice)
            const isNearBottom = container.scrollTop + container.clientHeight >= container.scrollHeight - 50;
            if (isNearBottom && newMessages.length > 0) {
                container.scrollTop = container.scrollHeight;
            }
        }
        
        // Render a single message element
        async function renderSingleMessage(msg, container, preDecrypted = null) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${msg.sender === currentUser ? 'own' : ''}`;
            messageDiv.dataset.msgId = msg.contentId || `${msg.timestamp}-${msg.sender}`;
            
            // Use pre-decrypted content if available (from incremental display)
            const decrypted = preDecrypted || await decryptMessage(msg.encryptedData, msg.keyData, currentRoom.id);
            
            if (decrypted.success) {
                messageDiv.innerHTML = `
                    <div class="message-header">
                        <span>${escapeHtml(msg.sender)}</span>
                        <div>
                            <span class="encryption-badge">EMRLD</span>
                            <span class="text-muted">
                                ${new Date(msg.timestamp).toLocaleTimeString()}
                            </span>
                        </div>
                    </div>
                    <div class="message-content">${escapeHtml(decrypted.message)}</div>
                `;
            } else {
                // Show encrypted message if decryption fails
                messageDiv.className += ' message-encrypted';
                messageDiv.innerHTML = `
                    <div class="message-header">
                        <span>${escapeHtml(msg.sender)}</span>
                        <div>
                            <span class="encryption-badge encrypted">ENCRYPTED</span>
                            <span class="text-error">
                                ${new Date(msg.timestamp).toLocaleTimeString()}
                            </span>
                        </div>
                    </div>
                    <div class="message-content">ðŸ”’ ${msg.encryptedData.substring(0, 100)}...</div>
                `;
            }
            
            container.appendChild(messageDiv);
        }

        // Message Refresh
        function refreshMessages() {
            loadMessages();
        }

        // Polling for new messages
        function startPolling() {
            if (messagePolling) clearInterval(messagePolling);
            messagePolling = setInterval(loadMessages, 3000); // Poll every 3 seconds
        }

        // Status Display
        function showStatus(message, type) {
            const statusDiv = document.getElementById('setupStatus');
            const statusClass = type === 'success' ? 'success-message' : 'error-message';
            statusDiv.innerHTML = `<div class="${statusClass}">${message}</div>`;
            setTimeout(() => statusDiv.innerHTML = '', 6000);
        }

        // Utility Functions
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Decryption function (matches the worker implementation)
        async function decryptMessage(encryptedDataB64, keyDataB64, context = 'default') {
            try {
                const encryptedData = base64ToArrayBuffer(encryptedDataB64);
                const quantumKey = base64ToArrayBuffer(keyDataB64);
                
                const aesData = xorWithKey(new Uint8Array(encryptedData), new Uint8Array(quantumKey));
                
                let data = aesData;
                const rounds = 3;
                
                for (let i = rounds - 1; i >= 0; i--) {
                    const roundKey = await deriveKey(context + i, `round-${i}`);
                    const iv = data.slice(0, 12);
                    const encrypted = data.slice(12);
                    
                    const decrypted = await crypto.subtle.decrypt(
                        { name: 'AES-GCM', iv },
                        roundKey,
                        encrypted
                    );
                    
                    data = new Uint8Array(decrypted);
                }
                
                const message = new TextDecoder().decode(data);
                return { success: true, message };
            } catch (error) {
                return { success: false, error: error.message };
            }
        }

        // Cryptographic utility functions
        async function deriveKey(password, salt) {
            const keyMaterial = await crypto.subtle.importKey(
                'raw',
                new TextEncoder().encode(password),
                'PBKDF2',
                false,
                ['deriveKey']
            );
            
            return crypto.subtle.deriveKey(
                {
                    name: 'PBKDF2',
                    salt: new TextEncoder().encode(salt),
                    iterations: 10000,
                    hash: 'SHA-256'
                },
                keyMaterial,
                { name: 'AES-GCM', length: 256 },
                true,
                ['encrypt', 'decrypt']
            );
        }

        function xorWithKey(data, key) {
            const result = new Uint8Array(data.length);
            for (let i = 0; i < data.length; i++) {
                result[i] = data[i] ^ key[i % key.length];
            }
            return result;
        }

        function base64ToArrayBuffer(base64) {
            const binary = atob(base64);
            const bytes = new Uint8Array(binary.length);
            for (let i = 0; i < binary.length; i++) {
                bytes[i] = binary.charCodeAt(i);
            }
            return bytes.buffer;
        }

        // Initialize app when DOM is ready
        document.addEventListener('DOMContentLoaded', initializeApp);
        
        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (messagePolling) {
                clearInterval(messagePolling);
            }
        });
    </script>
    <!-- Turnstile disabled for testing -->
    <!-- Turnstile verification callbacks removed for testing -->

    <noscript>
      <div class="error-message noscript-message">
        JavaScript is required to run Turnstile and use this app.
      </div>
    </noscript>
    <!-- Invisible turnstile widget removed for testing -->
</body>
</html>
