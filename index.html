<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Keyforge - Secure Messenger</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            min-height: 100vh;
            color: #333;
        }
        .container { 
            max-width: 1200px; 
            margin: 0 auto; 
            padding: 20px;
        }
        .header {
            background: white;
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }
        .header h1 {
            color: #1e3c72;
            font-size: 2.5rem;
            margin-bottom: 10px;
        }
        .badge {
            display: inline-block;
            background: #28a745;
            color: white;
            padding: 6px 15px;
            border-radius: 20px;
            font-size: 0.9rem;
            margin: 0 5px;
        }
        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        .card {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }
        .card h3 {
            color: #1e3c72;
            margin-bottom: 20px;
            font-size: 1.3rem;
        }
        .search-box {
            width: 100%;
            padding: 15px;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            font-size: 1rem;
            margin-bottom: 15px;
        }
        .search-box:focus {
            outline: none;
            border-color: #1e3c72;
        }
        .btn {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
            margin: 5px;
            width: 100%;
        }
        .btn-primary {
            background: #1e3c72;
            color: white;
        }
        .btn-success {
            background: #28a745;
            color: white;
        }
        .btn-secondary {
            background: #6c757d;
            color: white;
        }
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        .log-entry {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
            border-left: 3px solid #6c757d;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
        }
        .log-meta {
            display: flex;
            gap: 15px;
            font-size: 0.8rem;
            color: #666;
            margin-bottom: 8px;
        }
        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
        }
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        .stat-card {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }
        .stat-value {
            font-size: 2rem;
            font-weight: bold;
            color: #1e3c72;
        }
        .stat-label {
            color: #666;
            font-size: 0.9rem;
            margin-top: 5px;
        }
        .success-message {
            background: #d4edda;
            color: #155724;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            border: 1px solid #c3e6cb;
        }
        .error-message {
            background: #f8d7da;
            color: #721c24;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            border: 1px solid #f5c6cb;
        }
        
        /* EMRLD Specific Styles */
        .app {
            min-height: 100vh;
        }
        .logo {
            width: 90px;
            height: 90px;
            margin-right: 15px;
        }
        .subtitle {
            color: #666;
            font-size: 1.1rem;
            margin-bottom: 20px;
        }
        .info-banner {
            background: #e3f2fd;
            border: 1px solid #2196f3;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 30px;
            text-align: center;
        }
        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 30px;
        }
        .tab {
            flex: 1;
            padding: 15px;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            background: white;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
        }
        .tab.active {
            background: #1e3c72;
            color: white;
            border-color: #1e3c72;
        }
        .form-group {
            margin-bottom: 20px;
        }
        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #1e3c72;
        }
        .form-group input {
            width: 100%;
            padding: 15px;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            font-size: 1rem;
        }
        .form-group input:focus {
            outline: none;
            border-color: #1e3c72;
        }
        .features {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
        }
        .features h3 {
            margin-bottom: 15px;
        }
        .features ul {
            list-style: none;
        }
        .features li {
            padding: 8px 0;
            border-bottom: 1px solid #e9ecef;
        }
        .features li:last-child {
            border-bottom: none;
        }
        .hidden {
            display: none;
        }
        
        /* Chat Interface Styles */
        .chat-header {
            background: white;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        .room-info {
            background: white;
            border-radius: 15px;
            padding: 15px 20px;
            margin-bottom: 20px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.05);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .status-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .pulse {
            width: 8px;
            height: 8px;
            background: #28a745;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        .messages {
            background: white;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            height: 400px;
            overflow-y: auto;
        }
        .message {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 15px;
            border-left: 4px solid #6c757d;
        }
        .message.own {
            background: #e3f2fd;
            border-left-color: #1e3c72;
            margin-left: 20%;
        }
        .message-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            font-size: 0.9rem;
        }
        .encryption-badge {
            background: #28a745;
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 600;
        }
        .message-content {
            font-size: 1rem;
            line-height: 1.4;
        }
        .input-area {
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }
        .input-group {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        .input-group input {
            flex: 1;
            padding: 15px;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            font-size: 1rem;
        }
        .input-group input:focus {
            outline: none;
            border-color: #1e3c72;
        }
        .input-group button {
            width: auto;
            margin: 0;
        }
        .decrypt-area {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 15px;
        }
        .decrypt-area strong {
            color: #1e3c72;
        }
    </style>
    <link rel="icon" href="/logo_ani01.svg" type="image/svg+xml">
    <meta name="description" content="No Wizard Needed - Just Quantum-Grade Encryption. Secure end-to-end encrypted messaging with EMRLD Chain technology.">
    <meta name="keywords" content="encryption, secure messaging, quantum, EMRLD, end-to-end">
</head>
<body>
    <div class="app">
        <div class="container">
            <!-- Setup Screen -->
            <div id="setupScreen">
                <div class="header">
                    <div style="display: flex; align-items: center; justify-content: center; margin-bottom: 20px;">
                        <img src="/logo_ani01.svg" alt="Keyforge Logo" class="logo" onerror="this.style.display='none';">
                        <h1>Keyforge</h1>
                    </div>
                    <p class="subtitle">Private. Encrypted. Future-proof messaging.</p>
                </div>
                
                <div class="info-banner">
                    <strong>Enhanced Multi-Round Layered Diffusion (EMRLD) Chain</strong><br>
                    8-Pass AES-256-CBC with 2048-bit PBKDF2 Key Derivation + Simulated QKD<br>
                    Quantum-resistant hybrid encryption • Multi-layer defense against quantum attacks • NIST-aligned PQC framework
                </div>
                
                <div class="tabs">
                    <button class="tab active" onclick="switchTab('create')">
                        <span>Create Room</span>
                    </button>
                    <button class="tab" onclick="switchTab('join')">
                        <span>Join Room</span>
                    </button>
                </div>
                
                <div class="grid">
                    <div class="card">
                        <div id="createTab">
                            <h3>Start a Secure Chat</h3>
                            <div class="form-group">
                                <label for="createRoomName">Room Name</label>
                                <input type="text" id="createRoomName" placeholder="Quantum-Safe Chat Room" maxlength="50">
                            </div>
                            <div class="form-group">
                                <label for="createPassword">Room Password</label>
                                <input type="password" id="createPassword" placeholder="Room Password (at least 6 characters)" minlength="6">
                            </div>
                            <div class="form-group">
                                <label for="createUserName">Your Name</label>
                                <input type="text" id="createUserName" placeholder="Your Name" maxlength="30">
                            </div>
                            <button class="btn btn-primary" onclick="createRoom()">
                                Create Secure Room
                            </button>
                        </div>
                        
                        <div id="joinTab" class="hidden">
                            <h3>Join Existing Room</h3>
                            <div class="form-group">
                                <label for="joinRoomId">Room ID</label>
                                <input type="text" id="joinRoomId" placeholder="emerald_abc123" pattern="emerald_[a-zA-Z0-9]{8}">
                            </div>
                            <div class="form-group">
                                <label for="joinPassword">Room Password</label>
                                <input type="password" id="joinPassword" placeholder="Room password" minlength="6">
                            </div>
                            <div class="form-group">
                                <label for="joinUserName">Your Name</label>
                                <input type="text" id="joinUserName" placeholder="Your Name" maxlength="30">
                            </div>
                            <button class="btn btn-success" onclick="joinRoom()">
                                Join Secure Chat
                            </button>
                        </div>
                    </div>
                    
                    <div class="card">
                        <div class="features">
                            <h3>🛡️ Quantum-Resistant Security</h3>
                            <ul>
                                <li>8-Pass AES-256-CBC multi-round encryption</li>
                                <li>2048-bit PBKDF2 key derivation (1.6M iterations)</li>
                                <li>Simulated QKD with privacy amplification</li>
                                <li>XOR masking with quantum-inspired keys</li>
                                <li>Resistance to Grover's algorithm attacks</li>
                                <li>NIST PQC-aligned hybrid architecture</li>
                            </ul>
                        </div>
                    </div>
                </div>
                
                <div id="setupStatus"></div>
            </div>
        
            <!-- Main Chat Interface -->
            <div id="chatScreen" class="hidden">
                <div class="chat-header">
                    <div style="display: flex; align-items: center;">
                        <img src="/logo_ani01.svg" alt="Keyforge" class="logo" onerror="this.style.display='none';">
                        <div>
                            <h1 id="roomTitle">Keyforge Sanctuary</h1>
                            <p class="subtitle">Secure • Encrypted • Protected</p>
                        </div>
                    </div>
                    <div class="badge">Live Chat</div>
                </div>
                
                <div class="room-info">
                    <div class="room-details">
                        <div id="roomDetails">
                            Room: <span id="roomIdSpan" onclick="copyRoomId()" style="cursor: pointer; color: #1e3c72; text-decoration: underline;" title="Click to copy Room ID">emerald_demo</span> • User: Dorothy
                        </div>
                    </div>
                    <div class="status-indicator">
                        <div class="pulse"></div>
                        <span>Secured</span>
                    </div>
                </div>
                
                <div class="messages" id="messagesContainer">
                    <!-- Messages will be dynamically loaded here -->
                    <div class="message">
                        <div class="message-header">
                            <span>Welcome Bot</span>
                            <div>
                                <span class="encryption-badge">EMRLD</span>
                                <span style="color: #64748b; font-weight: normal; margin-left: 8px;">
                                    <script>document.write(new Date().toLocaleTimeString())</script>
                                </span>
                            </div>
                        </div>
                        <div class="message-content">
                            Welcome to Keyforge! Your messages are protected by the EMRLD Chain hybrid encryption framework. 
                            Each message undergoes 8-pass AES-256-CBC encryption with simulated QKD key masking for quantum resistance.
                        </div>
                    </div>
                </div>
                
                <div class="input-area">
                    <div class="input-group">
                        <input 
                            type="text" 
                            id="messageInput" 
                            placeholder="Type a secure message..." 
                            maxlength="1000"
                            onkeypress="if(event.key==='Enter' && !event.shiftKey) { event.preventDefault(); sendMessage(); }"
                            autocomplete="off"
                        >
                        <button class="btn btn-success" onclick="sendMessage()" title="Send Message">
                            Send
                        </button>
                        <button class="btn btn-secondary" onclick="refreshMessages()" title="Refresh Messages">
                            Refresh
                        </button>
                    </div>
                    
                    <div class="decrypt-area">
                        <strong>EMRLD Chain Decryption Active</strong>
                        <p>Messages automatically decrypted using 8-pass AES-256-CBC with QKD-derived key unmasking. 
                        Multi-layer quantum-resistant decryption ensures only authorized participants can access plaintext content.</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Application State
        let currentRoom = null;
        let currentUser = null;
        let messagePolling = null;
        let isLoading = false;
        let renderedIds = new Set();
        let polling = null;
        let messageCache = new Map();
        let lastMessageId = null;
        let optimisticMessages = new Map();

        // Initialize application
        function initializeApp() {
            console.log('Keyforge initialized');
            
            // Add loading states to buttons
            document.querySelectorAll('button').forEach(btn => {
                btn.addEventListener('click', function() {
                    if (!this.disabled) {
                        this.classList.add('loading');
                        setTimeout(() => this.classList.remove('loading'), 1000);
                    }
                });
            });
        }

        // Tab Management
        function switchTab(tab) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab')[tab === 'create' ? 0 : 1].classList.add('active');
            
            document.getElementById('createTab').classList.toggle('hidden', tab !== 'create');
            document.getElementById('joinTab').classList.toggle('hidden', tab !== 'join');
        }

        // Room Creation
        async function createRoom() {
            if (isLoading) return;
            isLoading = true;

            const roomName = document.getElementById('createRoomName').value.trim();
            const password = document.getElementById('createPassword').value;
            const userName = document.getElementById('createUserName').value.trim();

            if (!roomName || !password || !userName) {
                showStatus('Please fill in all fields', 'error');
                isLoading = false;
                return;
            }
            if (password.length < 6) {
                showStatus('Password must be at least 6 characters for security', 'error');
                isLoading = false;
                return;
            }

            try {
                // 1) Create
                const createRes = await fetch('/api/room/create', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ roomName, password })
                });
                const createJson = await createRes.json();
                if (!createJson.success) {
                    showStatus(`Failed to create room: ${createJson.error}`, 'error');
                    return;
                }

                const roomId = createJson.roomId;
                // Prefill the join box for convenience
                document.getElementById('joinRoomId').value = roomId;

                // 2) Immediately join the room we just created
                const joinRes = await fetch('/api/room/join', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ roomId, password })
                });
                const joinJson = await joinRes.json();
                if (!joinJson.success) {
                    showStatus(`Created but could not join: ${joinJson.error}`, 'error');
                    return;
                }

                // 3) Enter chat
                currentRoom = { id: roomId, name: joinJson.room.name || roomName, password };
                currentUser = userName;
                enterChat();
                showStatus(`Your secure chat room has been created. Share this Room ID and password to invite others.: ${roomId}`, 'success');
            } catch (e) {
                showStatus(`Network error: ${e.message}`, 'error');
            } finally {
                isLoading = false;
            }
        }

        // Room Joining
        async function joinRoom() {
            if (isLoading) return;
            isLoading = true;

            const roomId = document.getElementById('joinRoomId').value.trim();
            const password = document.getElementById('joinPassword').value;
            const userName = document.getElementById('joinUserName').value.trim();
            
            // Validation
            if (!roomId || !password || !userName) {
                showStatus('All fields are required', 'error');
                isLoading = false;
                return;
            }
            
            if (!roomId.startsWith('emerald_')) {
                showStatus('Invalid room ID format. Should start with "emerald_"', 'error');
                isLoading = false;
                return;
            }
            
            try {
                const response = await fetch('/api/room/join', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ roomId, password })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    currentRoom = { id: roomId, name: result.room.name, password };
                    currentUser = userName;
                    enterChat();
                    showStatus('Welcome to Keyforge!', 'success');
                } else {
                    showStatus(`Access denied: ${result.error}`, 'error');
                }
            } catch (error) {
                showStatus(`Connection error: ${error.message}`, 'error');
            } finally {
                isLoading = false;
            }
        }

        // Enter Chat Interface with proper state management
        function enterChat() {
            // Reset state for new room/view (security & stability)
            try { 
                renderedIds.clear(); 
                messageCache.clear();
                optimisticMessages.clear();
            } catch {}
            if (polling) { clearInterval(polling); polling = null; }
            if (messagePolling) { clearInterval(messagePolling); messagePolling = null; }
            lastMessageId = null;

            document.getElementById('setupScreen').classList.add('hidden');
            document.getElementById('chatScreen').classList.remove('hidden');

            document.getElementById('roomTitle').textContent = currentRoom.name || 'Room';
            document.getElementById('roomDetails').textContent =
                `Room id: ${currentRoom.id} • User: ${currentUser} • Invite with Room id and password`;

            const box = document.getElementById('messagesContainer');
            box.innerHTML = '';

            // Kick off fresh load + polling
            loadMessages();
            polling = setInterval(loadMessages, 3000);
        }

        // Message Sending with optimistic updates
        async function sendMessage() {
            const messageText = document.getElementById('messageInput').value.trim();
            if (!messageText || isLoading) return;
            
            isLoading = true;
            const inputField = document.getElementById('messageInput');
            const originalValue = inputField.value;
            inputField.value = '';
            inputField.disabled = true;
            
            // Generate optimistic message ID
            const optimisticId = `${Date.now()}-${currentUser}-optimistic`;
            const container = document.getElementById('messagesContainer');
            
            // Add optimistic message immediately
            const optimisticMsg = {
                timestamp: Date.now(),
                sender: currentUser,
                encryptedData: 'optimistic',
                keyData: 'optimistic'
            };
            
            // Create optimistic message element
            const messageDiv = document.createElement('div');
            messageDiv.className = `message own optimistic-message`;
            messageDiv.dataset.msgId = optimisticId;
            messageDiv.style.opacity = '0.7';
            messageDiv.innerHTML = `
                <div class="message-header">
                    <span>${escapeHtml(currentUser)}</span>
                    <div>
                        <span class="encryption-badge" style="background: #f59e0b;">SENDING</span>
                        <span style="color: #64748b; font-weight: normal; margin-left: 8px;">
                            ${new Date().toLocaleTimeString()}
                        </span>
                    </div>
                </div>
                <div class="message-content">${escapeHtml(messageText)}</div>
            `;
            container.appendChild(messageDiv);
            container.scrollTop = container.scrollHeight;
            
            optimisticMessages.set(optimisticId, messageDiv);
            
            try {
                const response = await fetch('/api/message/send', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        roomId: currentRoom.id,
                        message: messageText,
                        senderName: currentUser
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    // Update optimistic message to confirmed state
                    messageDiv.style.opacity = '1';
                    const badge = messageDiv.querySelector('.encryption-badge');
                    badge.textContent = 'EMRLD';
                    badge.style.background = '#10b981';
                    
                    // Load new messages to get the real encrypted version
                    setTimeout(() => loadMessages(), 500);
                } else {
                    // Remove optimistic message and restore input
                    messageDiv.remove();
                    optimisticMessages.delete(optimisticId);
                    inputField.value = originalValue;
                    alert(`Failed to send: ${result.error}`);
                }
            } catch (error) {
                // Remove optimistic message and restore input
                messageDiv.remove();
                optimisticMessages.delete(optimisticId);
                inputField.value = originalValue;
                alert(`Network error: ${error.message}`);
            } finally {
                inputField.disabled = false;
                isLoading = false;
            }
        }

        // Message Loading with deduplication and error recovery
        async function loadMessages(retries = 3) {
            if (!currentRoom) return;
            
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 10000); // 10s timeout
                
                const response = await fetch(`/api/room/${currentRoom.id}/messages`, {
                    signal: controller.signal
                });
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const result = await response.json();
                
                if (result.success) {
                    await displayMessagesIncremental(result.messages);
                    // Reset connection health indicator
                    updateConnectionStatus(true);
                } else {
                    throw new Error(result.error || 'Unknown server error');
                }
            } catch (error) {
                console.error('Failed to load messages:', error);
                updateConnectionStatus(false);
                
                // Exponential backoff retry for network errors
                if (retries > 0 && (error.name === 'AbortError' || error.message.includes('fetch'))) {
                    const delay = Math.pow(2, 3 - retries) * 1000; // 1s, 2s, 4s
                    setTimeout(() => loadMessages(retries - 1), delay);
                }
            }
        }
        
        // Connection status indicator
        function updateConnectionStatus(isConnected) {
            const statusElement = document.querySelector('.status-indicator span');
            if (!statusElement) return;
            
            if (isConnected) {
                statusElement.textContent = '🔒 Secured';
                statusElement.style.color = '#10b981';
            } else {
                statusElement.textContent = '⚠️ Reconnecting...';
                statusElement.style.color = '#f59e0b';
            }
        }

        // Incremental Message Display (prevents flashing)
        async function displayMessagesIncremental(messages) {
            const container = document.getElementById('messagesContainer');
            
            // Create content-based message ID for proper deduplication
            const getContentId = (msg, decryptedText = null) => {
                // Use sender + decrypted content + approximate time for deduplication
                const timeWindow = Math.floor(msg.timestamp / 5000) * 5000; // 5s window
                return `${msg.sender}-${decryptedText || 'encrypted'}-${timeWindow}`;
            };
            
            // Track which messages are new
            const newMessages = [];
            for (const msg of messages) {
                try {
                    // Try to decrypt to get content-based ID
                    const decrypted = await decryptMessage(msg.encryptedData, msg.keyData, currentRoom.id);
                    const contentId = getContentId(msg, decrypted.success ? decrypted.message : null);
                    
                    if (!renderedIds.has(contentId)) {
                        renderedIds.add(contentId);
                        newMessages.push({ ...msg, contentId, decrypted });
                    }
                } catch (error) {
                    // Fallback to timestamp-based ID for undecryptable messages
                    const fallbackId = `${msg.timestamp}-${msg.sender}-${msg.encryptedData.substring(0, 20)}`;
                    if (!renderedIds.has(fallbackId)) {
                        renderedIds.add(fallbackId);
                        newMessages.push({ ...msg, contentId: fallbackId, decrypted: { success: false } });
                    }
                }
            }
            
            // Remove any optimistic messages that match the real messages
            for (const msg of newMessages) {
                // Remove optimistic messages for the same content
                const optimisticToRemove = [];
                for (const [optimisticId, element] of optimisticMessages.entries()) {
                    const optimisticContent = element.querySelector('.message-content')?.textContent;
                    const realContent = msg.decrypted.success ? msg.decrypted.message : null;
                    
                    if (optimisticContent && realContent && optimisticContent.trim() === realContent.trim() && 
                        element.querySelector('.message-header span')?.textContent === msg.sender) {
                        optimisticToRemove.push(optimisticId);
                        element.remove();
                    }
                }
                optimisticToRemove.forEach(id => optimisticMessages.delete(id));
            }
            
            // Only render new messages
            for (const msg of newMessages) {
                await renderSingleMessage(msg, container, msg.decrypted);
            }
            
            // Auto-scroll only if user is near bottom (UX best practice)
            const isNearBottom = container.scrollTop + container.clientHeight >= container.scrollHeight - 50;
            if (isNearBottom && newMessages.length > 0) {
                container.scrollTop = container.scrollHeight;
            }
        }
        
        // Render a single message element
        async function renderSingleMessage(msg, container, preDecrypted = null) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${msg.sender === currentUser ? 'own' : ''}`;
            messageDiv.dataset.msgId = msg.contentId || `${msg.timestamp}-${msg.sender}`;
            
            // Use pre-decrypted content if available (from incremental display)
            const decrypted = preDecrypted || await decryptMessage(msg.encryptedData, msg.keyData, currentRoom.id);
            
            if (decrypted.success) {
                messageDiv.innerHTML = `
                    <div class="message-header">
                        <span>${escapeHtml(msg.sender)}</span>
                        <div>
                            <span class="encryption-badge">EMRLD</span>
                            <span style="color: #64748b; font-weight: normal; margin-left: 8px;">
                                ${new Date(msg.timestamp).toLocaleTimeString()}
                            </span>
                        </div>
                    </div>
                    <div class="message-content">${escapeHtml(decrypted.message)}</div>
                `;
            } else {
                // Show encrypted message if decryption fails
                messageDiv.className += ' message-encrypted';
                messageDiv.innerHTML = `
                    <div class="message-header">
                        <span>${escapeHtml(msg.sender)}</span>
                        <div>
                            <span style="background: #dc2626; color: white; font-size: 10px; padding: 4px 8px; border-radius: 6px;">ENCRYPTED</span>
                            <span style="color: #991b1b; font-weight: normal; margin-left: 8px;">
                                ${new Date(msg.timestamp).toLocaleTimeString()}
                            </span>
                        </div>
                    </div>
                    <div class="message-content">🔒 ${msg.encryptedData.substring(0, 100)}...</div>
                `;
            }
            
            container.appendChild(messageDiv);
        }

        // Message Refresh
        function refreshMessages() {
            loadMessages();
        }

        // Polling for new messages
        function startPolling() {
            if (messagePolling) clearInterval(messagePolling);
            messagePolling = setInterval(loadMessages, 3000); // Poll every 3 seconds
        }

        // Status Display
        function showStatus(message, type) {
            const statusDiv = document.getElementById('setupStatus');
            const statusClass = type === 'success' ? 'success-message' : 'error-message';
            statusDiv.innerHTML = `<div class="${statusClass}">${message}</div>`;
            setTimeout(() => statusDiv.innerHTML = '', 6000);
        }

        // Utility Functions
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Decryption function (matches the worker implementation)
        async function decryptMessage(encryptedDataB64, keyDataB64, context = 'default') {
            try {
                const encryptedData = base64ToArrayBuffer(encryptedDataB64);
                const quantumKey = base64ToArrayBuffer(keyDataB64);
                
                const aesData = xorWithKey(new Uint8Array(encryptedData), new Uint8Array(quantumKey));
                
                let data = aesData;
                const rounds = 3;
                
                for (let i = rounds - 1; i >= 0; i--) {
                    const roundKey = await deriveKey(context + i, `round-${i}`);
                    const iv = data.slice(0, 12);
                    const encrypted = data.slice(12);
                    
                    const decrypted = await crypto.subtle.decrypt(
                        { name: 'AES-GCM', iv },
                        roundKey,
                        encrypted
                    );
                    
                    data = new Uint8Array(decrypted);
                }
                
                const message = new TextDecoder().decode(data);
                return { success: true, message };
            } catch (error) {
                return { success: false, error: error.message };
            }
        }

        // Cryptographic utility functions
        async function deriveKey(password, salt) {
            const keyMaterial = await crypto.subtle.importKey(
                'raw',
                new TextEncoder().encode(password),
                'PBKDF2',
                false,
                ['deriveKey']
            );
            
            return crypto.subtle.deriveKey(
                {
                    name: 'PBKDF2',
                    salt: new TextEncoder().encode(salt),
                    iterations: 10000,
                    hash: 'SHA-256'
                },
                keyMaterial,
                { name: 'AES-GCM', length: 256 },
                true,
                ['encrypt', 'decrypt']
            );
        }

        function xorWithKey(data, key) {
            const result = new Uint8Array(data.length);
            for (let i = 0; i < data.length; i++) {
                result[i] = data[i] ^ key[i % key.length];
            }
            return result;
        }

        function base64ToArrayBuffer(base64) {
            const binary = atob(base64);
            const bytes = new Uint8Array(binary.length);
            for (let i = 0; i < binary.length; i++) {
                bytes[i] = binary.charCodeAt(i);
            }
            return bytes.buffer;
        }

        // Initialize app when DOM is ready
        document.addEventListener('DOMContentLoaded', initializeApp);
        
        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (messagePolling) {
                clearInterval(messagePolling);
            }
        });
    </script>
</body>
</html>
