<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Key-forge - Secure Messenger</title>

    <!-- CSP Header (prefer server-side headers for HSTS, X-Content-Type-Options, etc.) -->
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' https://challenges.cloudflare.com 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src 'self' data:; connect-src 'self' https://challenges.cloudflare.com; frame-src https://challenges.cloudflare.com; base-uri 'none'; form-action 'self'; upgrade-insecure-requests;">

    <!--
    PRODUCTION: Move these to server response headers for proper enforcement:
    Strict-Transport-Security: max-age=31536000; includeSubDomains; preload
    X-Content-Type-Options: nosniff
    Referrer-Policy: strict-origin-when-cross-origin
    -->

    <link rel="stylesheet" href="styles.css">
    <link rel="icon" href="/logo_ani01.svg" type="image/svg+xml">
    <meta name="description" content="Quantum-Grade Encryption. Secure end-to-end encrypted messaging with EMRLD Chain technology.">
    <meta name="keywords" content="encryption, secure messaging, quantum, EMRLD, end-to-end">
</head>
<body>
    <div class="app">
        <div class="container">
            <!-- Initial Verification Screen -->
            <div id="verificationScreen">
                <div class="header">
                    <div class="logo-container">
                        <img src="/keyforge.svg" alt="Keyforge" class="logo-text">
                        <img src="/logo_ani01.svg" alt="Keyforge Logo" class="logo-icon">
                    </div>
                    <p class="subtitle">Secure Access Verification</p>
                </div>

                <div class="card card-centered">
                    <div class="text-center mb-6">
                        <img src="/shield.svg" alt="Shield" class="img-md">
                    </div>
                    <h3 class="h3-center">Security Check</h3>

                    <!-- Visible Turnstile widget for first verification -->
                    <div class="text-center mb-6">
                        <div id="ts-visible"></div>
                    </div>

                    <div id="verificationStatus" aria-live="polite"></div>
                </div>
            </div>

            <!-- Setup Screen -->
            <div id="setupScreen" class="hidden">
                <div class="header">
                    <div class="logo-container">
                        <img src="/keyforge.svg" alt="Keyforge" class="logo-text">
                        <img src="/logo_ani01.svg" alt="Keyforge Logo" class="logo-icon">
                    </div>
                    <p class="subtitle">Secure Messaging</p>
                </div>
                
                <div class="info-banner">
                    <strong>Enhanced Multi-Round Layered Diffusion (EMRLD) Chain</strong><br>
                    Resilient • Layered • Quantum Secure
                </div>
                
                <div class="tabs" role="tablist" aria-label="Room actions">
                    <button id="createTabBtn" class="tab active" role="tab" aria-selected="true" aria-controls="createCard"
                            onclick="switchTab('create')">
                        <span>Forge Room</span>
                    </button>
                    <button id="joinTabBtn" class="tab" role="tab" aria-selected="false" aria-controls="joinCard"
                            onclick="switchTab('join')">
                        <span>Join Room</span>
                    </button>
                </div>
                
                <div class="grid">
                  <div class="card" id="createCard" role="tabpanel" aria-labelledby="createTabBtn">
                    <form id="createTab" onsubmit="event.preventDefault(); createRoom();">
                      <h3>Start a Secure Chat</h3>
                      <div class="form-group">
                        <label for="createRoomName">Room Name</label>
                        <input type="text" id="createRoomName" placeholder="My Chat Room" maxlength="50" required>
                      </div>
                      <div class="form-group">
                        <label for="createPassword">Room Password</label>
                        <input type="password" id="createPassword" placeholder="Room Password (min length: 6)" minlength="6" autocomplete="new-password" required>
                      </div>
                      <div class="form-group">
                        <label for="createUserName">Your Name</label>
                        <input type="text" id="createUserName" placeholder="Your Name" maxlength="30" required>
                      </div>

                      <button id="createBtn" class="btn btn-primary" type="submit">
                        Forge Secure Room
                      </button>
                    </form>
                  </div>

                  <!-- NEW: Join card lives in the same grid and has the same styling -->
                  <div class="card hidden" id="joinCard" role="tabpanel" aria-labelledby="joinTabBtn">
                    <form id="joinTab" onsubmit="event.preventDefault(); joinRoom();">
                      <h3>Join Existing Room</h3>
                      <div class="form-group">
                        <label for="joinRoomId">Room ID</label>
                        <input type="text" id="joinRoomId" placeholder="emerald_ab12CD34"
                               pattern="emerald_[A-Za-z0-9]{8}"
                               title='Format: "emerald_" followed by 8 letters or numbers'
                               required>
                      </div>
                      <div class="form-group">
                        <label for="joinPassword">Room Password</label>
                        <input type="password" id="joinPassword" placeholder="Room password" minlength="6" autocomplete="current-password" required>
                      </div>
                      <div class="form-group">
                        <label for="joinUserName">Your Name</label>
                        <input type="text" id="joinUserName" placeholder="Your Name" maxlength="30" required>
                      </div>

                      <button id="joinBtn" class="btn btn-success" type="submit">
                        Join Secure Chat
                      </button>
                    </form>
                  </div>

                  <div class="card features-card">
                        <div class="features">
                            <img src="/shield.svg" alt="Shield" class="img-md img-inline">
                            <h3>Key-forge Security</h3>
                            <ul>
                                <li>8-Pass AES-256-CBC multi-round encryption</li>
                                <li>2048-bit PBKDF2 key derivation (1.6M iterations)</li>
                                <li>QKD with privacy amplification</li>
                                <li>XOR masking with quantum-inspired keys</li>
                                <li>NIST PQC-aligned hybrid architecture</li>
                            </ul>
                        </div>
                    </div>
                </div>
                
                <div id="setupStatus" aria-live="polite"></div>
            </div>
        
            <!-- Main Chat Interface -->
            <div id="chatScreen" class="hidden">
                <div class="chat-header">
                    <div class="chat-logo-container">
                        <img src="/keyforge.svg" alt="Keyforge" class="chat-logo-text">
                        <img src="/logo_ani01.svg" alt="Keyforge" class="chat-logo-icon">
                        <div class="ml-3">
                            <h1 id="roomTitle" class="chat-room-title">room title</h1>
                        </div>
                    </div>
                   <!-- <div class="badge">Live</div> -->
                </div>
                
                <div class="room-info">
                    <div class="room-details">
                        <div id="roomDetails">
                            Room ID: <span id="roomIdSpan" onclick="copyRoomId()" class="room-id-clickable" title="Click to copy Room ID">emerald_demo</span> • User: Placeholder
                        </div>
                    </div>
                    <div class="status-indicator">
                        <div class="pulse"></div>
                        <span>Secured</span>
                    </div>
                </div>
                
                <div class="messages" id="messagesContainer">
                    <!-- Messages will be dynamically loaded here -->
                    <div class="message">
                        <div class="message-header">
                            <span>Welcome Bot</span>
                            <div>
                                <span class="encryption-badge">EMRLD</span>
                                <span class="text-muted">
                                    <script>document.write(new Date().toLocaleTimeString())</script>
                                </span>
                            </div>
                        </div>
                        <div class="message-content">
                            Welcome to Key-forge! Your messages are protected by the EMRLD Chain hybrid encryption framework. 
                            Each message undergoes 8-pass AES-256-CBC encryption with QKD key masking.
                        </div>
                    </div>
                </div>

                <!-- keep your messagesContainer exactly as you have it -->

                <div class="input-area">
                <!-- Full-width input at the top -->
                 <div class="input-wrapper">
                 <input
                      type="text"
                      id="messageInput"
                     placeholder="Type..."
                     maxlength="1000"
                     onkeypress="if(event.key==='Enter' && !event.shiftKey) { event.preventDefault(); sendMessage(); }"
                     autocomplete="off"
                     aria-label="Type a secure message"
                    />
                 </div>

                <!-- Buttons live together on one row -->
                <div class="composer-actions">
                  <button class="btn btn-success" onclick="sendMessage()" title="Send Message">Send</button>
                  <button class="btn btn-secondary" onclick="refreshMessages()" title="Refresh Messages">Refresh</button>
                 <button class="btn btn-secondary" onclick="shareInvite()" title="Share Invite Link">Forge Invite</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Development Environment Detection
        const IS_LOCAL = /^(localhost|127\.0\.0\.1)$/.test(location.hostname);
        const TS_SITEKEY = IS_LOCAL
            ? '1x00000000000000000000AA'  // Official Turnstile test key
            : '0x4AAAAAAB1C2uOH0-FlPCYd';  // Production key

        console.log(`Environment: ${IS_LOCAL ? 'LOCAL' : 'PRODUCTION'}, Using sitekey: ${TS_SITEKEY}`);

        // Application State
        let currentRoom = null;
        let currentUser = null;
        let messagePolling = null;
        let isLoading = false;
        let renderedIds = new Set();
        let messageCache = new Map();
        let lastMessageId = null;
        let optimisticMessages = new Map();

        // Session-scoped verification
        const VERIFIED_KEY = "turnstile:v1:verifiedAt";
        const VERIFIED_TTL_MS = 30 * 60 * 1000; // 30 minutes

        function isSessionVerified() {
            const t = Number(sessionStorage.getItem(VERIFIED_KEY) || 0);
            return t && (Date.now() - t) < VERIFIED_TTL_MS;
        }

        // Simplified: Only visible widget for initial verification
        let hasInitializedUI = false;

        // First verification callback
        window.onFirstVerify = function(token) {
            console.log('First verification successful');
            sessionStorage.setItem(VERIFIED_KEY, String(Date.now()));
            if (!hasInitializedUI) {
                showMainInterface();   // only once
                hasInitializedUI = true;
            } else {
                console.log("Token refreshed silently");
                // just store token and continue, don’t reset UI
            }
        };


        // Simple fetch helper
        async function simpleFetch(url, body) {
            console.log(`Making request to ${url}`);
            return fetch(url, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(body)
            });
        }

        // CSP Violation Monitoring (development aid)
        window.addEventListener('securitypolicyviolation', e => {
            console.warn('CSP blocked:', e.blockedURI, e.violatedDirective);
        });

        // Initialize application
        function initializeApp() {
            console.log('Keyforge initialized');

            if (isSessionVerified()) {
                if (!hasInitializedUI) {
                    showMainInterface();
                    hasInitializedUI = true;
                }
            } else {
                showVerificationScreen();
            }

    // button loading states remain the same...


            // Add loading states to buttons
            document.querySelectorAll('button').forEach(btn => {
                btn.addEventListener('click', function() {
                    if (!this.disabled) {
                        this.classList.add('is-loading');
                        setTimeout(() => this.classList.remove('is-loading'), 1000);
                    }
                });
            });
        }

        // Show verification screen
        function showVerificationScreen() {
            document.getElementById('verificationScreen').classList.remove('hidden');
            document.getElementById('setupScreen').classList.add('hidden');
            document.getElementById('chatScreen').classList.add('hidden');
        }

        // Show main interface after verification
        function showMainInterface() {
            document.getElementById('verificationScreen').classList.add('hidden');
            document.getElementById('setupScreen').classList.remove('hidden');
            document.getElementById('chatScreen').classList.add('hidden');
            console.log('Showing main interface');

            // Handle URL-based tab persistence and room prefilling
            const qs = new URLSearchParams(location.search);
            if (location.hash === '#join' || qs.get('tab') === 'join') {
                switchTab('join');
            }
            const room = qs.get('room');
            if (room) {
                switchTab('join');
                document.getElementById('joinRoomId').value = room;
            }
        }

        // Tab Management
        function switchTab(tab) {
            // tab button state
            const tabs = document.querySelectorAll('.tab');
            tabs.forEach(t => {
                t.classList.remove('active');
                t.setAttribute('aria-selected', 'false');
            });
            const activeTab = tabs[tab === 'create' ? 0 : 1];
            activeTab.classList.add('active');
            activeTab.setAttribute('aria-selected', 'true');

            // show/hide whole cards so the styling stays consistent
            const createCard = document.getElementById('createCard');
            const joinCard   = document.getElementById('joinCard');
            if (tab === 'create') {
                createCard.classList.remove('hidden');
                joinCard.classList.add('hidden');
                document.getElementById('createRoomName')?.focus();
            } else {
                createCard.classList.add('hidden');
                joinCard.classList.remove('hidden');
                document.getElementById('joinRoomId')?.focus();
            }
        }

        // Simplified: No verification required for actions after initial gate

        // Room Creation
        async function createRoom() {
            if (isLoading) return;
            isLoading = true;

            const roomName = document.getElementById('createRoomName').value.trim();
            const password = document.getElementById('createPassword').value;
            const userName = document.getElementById('createUserName').value.trim();

            if (!roomName || !password || !userName) {
                showStatus('Please fill in all fields', 'error');
                isLoading = false;
                return;
            }
            if (password.length < 6) {
                showStatus('Password must be at least 6 characters for security', 'error');
                isLoading = false;
                return;
            }

            try {
                // Create room
                console.log('Creating room...');
                const createRes = await simpleFetch('/api/room/create', {
                    roomName,
                    password
                });
                const createJson = await createRes.json();
                console.log('Create room response:', createJson);
                if (!createJson.success) {
                    showStatus(`Failed to create room: ${createJson.error}`, 'error');
                    return;
                }

                const roomId = createJson.roomId;
                console.log('Room created successfully:', roomId);
                // Prefill the join box for convenience
                document.getElementById('joinRoomId').value = roomId;

                // Auto-join the room we just created
                console.log('Auto-joining room...');
                const joinRes = await simpleFetch('/api/room/join', {
                    roomId,
                    password
                });
                const joinJson = await joinRes.json();
                console.log('Join room response:', joinJson);
                if (!joinJson.success) {
                    showStatus(`Created but could not join: ${joinJson.error}`, 'error');
                    return;
                }

                // 4) Enter chat
                console.log('Entering chat...');
                currentRoom = { id: roomId, name: joinJson.room.name || roomName, password };
                currentUser = userName;
                console.log('Current room set:', currentRoom);
                console.log('Current user set:', currentUser);

                // Show success message before switching screens
                showStatus(`Your secure chat room has been created. Room ID: ${roomId}`, 'success');

                // Small delay to let user see the success message, then switch
                setTimeout(() => {
                    enterChat();
                }, 1500);

            } catch (e) {
                showStatus(`Network error: ${e.message}`, 'error');
            } finally {
                isLoading = false;
            }
        }

        // Room Joining
        async function joinRoom() {
            if (isLoading) return;
            isLoading = true;

            const roomId = document.getElementById('joinRoomId').value.trim();
            const password = document.getElementById('joinPassword').value;
            const userName = document.getElementById('joinUserName').value.trim();


            // Validation
            if (!roomId || !password || !userName) {
                showStatus('All fields are required', 'error');
                isLoading = false;
                return;
            }
            
            if (!roomId.startsWith('emerald_')) {
                showStatus('Invalid room ID format. Should start with "emerald_"', 'error');
                isLoading = false;
                return;
            }
            
            try {
                // Join room
                console.log('Joining room...');
                const response = await simpleFetch('/api/room/join', {
                    roomId,
                    password
                });
                
                const result = await response.json();
                
                if (result.success) {
                    currentRoom = { id: roomId, name: result.room.name, password };
                    currentUser = userName;
                    enterChat();
                    showStatus('Welcome to Key-forge!', 'success');

                } else {
                    showStatus(`Access denied: ${result.error}`, 'error');
                }
            } catch (error) {
                showStatus(`Connection error: ${error.message}`, 'error');
            } finally {
                isLoading = false;
            }
        }

        // Enter Chat Interface with proper state management
        function enterChat() {
            console.log('enterChat() called');
            console.log('currentRoom:', currentRoom);
            console.log('currentUser:', currentUser);

            // Reset state for new room/view (security & stability)
            try {
                renderedIds.clear();
                messageCache.clear();
                optimisticMessages.clear();
            } catch {}
            if (messagePolling) { clearInterval(messagePolling); messagePolling = null; }
            lastMessageId = null;

            console.log('Switching screens...');
            const setupScreen = document.getElementById('setupScreen');
            const chatScreen = document.getElementById('chatScreen');
            console.log('setupScreen element:', setupScreen);
            console.log('chatScreen element:', chatScreen);

            setupScreen.classList.add('hidden');
            chatScreen.classList.remove('hidden');
            console.log('Screen switch complete');
            console.log('Setup screen hidden?', setupScreen.classList.contains('hidden'));
            console.log('Chat screen visible?', !chatScreen.classList.contains('hidden'));

            document.getElementById('roomTitle').textContent = currentRoom.name || 'Room';
            document.getElementById('roomDetails').innerHTML =
                `Room ID: <span id="roomIdSpan" onclick="copyRoomId()" class="room-id-clickable" title="Click to copy Room ID">${currentRoom.id}</span> • User: ${currentUser} • "Forge Invite" to share`;

            const box = document.getElementById('messagesContainer');
            box.innerHTML = '';

            console.log('Starting message loading...');
            // Kick off fresh load + polling
            loadMessages();
            // Polling interval - aligns with MESSAGE_POLL_INTERVAL in wrangler.toml
            messagePolling = setInterval(loadMessages, 3000);
            console.log('enterChat() complete');
        }

        // Copy Room ID to clipboard
        async function copyRoomId() {
            if (!currentRoom) return;

            try {
                await navigator.clipboard.writeText(currentRoom.id);

                // Show visual feedback
                const roomSpan = document.getElementById('roomIdSpan');
                const originalText = roomSpan.textContent;

                roomSpan.textContent = 'Copied!';
                roomSpan.style.color = '#28a745';

                // Reset after 1 second
                setTimeout(() => {
                    roomSpan.textContent = originalText;
                    roomSpan.style.color = '#1e3c72';
                }, 1000);

            } catch (err) {
                // Fallback for older browsers
                const textArea = document.createElement('textarea');
                textArea.value = currentRoom.id;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);

                // Show feedback
                const roomSpan = document.getElementById('roomIdSpan');
                const originalText = roomSpan.textContent;
                roomSpan.textContent = 'Copied!';

                setTimeout(() => {
                    roomSpan.textContent = originalText;
                }, 1000);
            }
        }

        // Share / copy an invite link that opens the Join tab with the room prefilled
        async function shareInvite() {
            if (!currentRoom) { showStatus('Create or join a room first', 'error'); return; }
            const url = new URL(location.origin + location.pathname);
            url.searchParams.set('tab', 'join');
            url.searchParams.set('room', currentRoom.id);
            url.hash = 'join';
            const link = url.toString();

            try {
                if (navigator.share) {
                    await navigator.share({ title: 'Join my Key-forge room', url: link });
                    return;
                }
                await navigator.clipboard.writeText(link);
                showStatus('Invite link copied to clipboard', 'success');
            } catch (_e) {
                try {
                    await navigator.clipboard.writeText(link);
                    showStatus('Invite link copied to clipboard', 'success');
                } catch {
                    showStatus('Unable to copy invite link', 'error');
                }
            }
        }
        
        // Message Sending with optimistic updates
        async function sendMessage() {
            const messageText = document.getElementById('messageInput').value.trim();
            if (!messageText || isLoading) return;
            
            isLoading = true;
            const inputField = document.getElementById('messageInput');
            const originalValue = inputField.value;
            inputField.value = '';
            inputField.disabled = true;
            
            // Generate optimistic message ID
            const optimisticId = `${Date.now()}-${currentUser}-optimistic`;
            const container = document.getElementById('messagesContainer');
            
            // Add optimistic message immediately
            const optimisticMsg = {
                timestamp: Date.now(),
                sender: currentUser,
                encryptedData: 'optimistic',
                keyData: 'optimistic'
            };
            
            // Create optimistic message element
            const messageDiv = document.createElement('div');
            messageDiv.className = `message own optimistic-message`;
            messageDiv.dataset.msgId = optimisticId;
            messageDiv.style.opacity = '0.7';
            messageDiv.innerHTML = `
                <div class="message-header">
                    <span>${escapeHtml(currentUser)}</span>
                    <div>
                        <span class="encryption-badge sending">SENDING</span>
                        <span class="text-muted">
                            ${new Date().toLocaleTimeString()}
                        </span>
                    </div>
                </div>
                <div class="message-content">${escapeHtml(messageText)}</div>
            `;
            container.appendChild(messageDiv);
            container.scrollTop = container.scrollHeight;
            
            optimisticMessages.set(optimisticId, messageDiv);
            
            try {
                // Send message
                const response = await simpleFetch('/api/message/send', {
                    roomId: currentRoom.id,
                    message: messageText,
                    senderName: currentUser
                });
                
                const result = await response.json();
                
                if (result.success) {
                    // Update optimistic message to confirmed state
                    messageDiv.style.opacity = '1';
                    const badge = messageDiv.querySelector('.encryption-badge');
                    badge.textContent = 'EMRLD';
                    badge.style.background = '#10b981';
                    
                    // Load new messages to get the real encrypted version
                    setTimeout(() => loadMessages(), 500);
                } else {
                    // Remove optimistic message and restore input
                    messageDiv.remove();
                    optimisticMessages.delete(optimisticId);
                    inputField.value = originalValue;
                    alert(`Failed to send: ${result.error}`);
                }
            } catch (error) {
                // Remove optimistic message and restore input
                messageDiv.remove();
                optimisticMessages.delete(optimisticId);
                inputField.value = originalValue;
                alert(`Network error: ${error.message}`);
            } finally {
                inputField.disabled = false;
                isLoading = false;
            }
        }

        // Message Loading with deduplication and error recovery
        async function loadMessages(retries = 3) {
            if (!currentRoom) return;
            
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 10000); // 10s timeout
                
                const response = await fetch(`/api/room/${currentRoom.id}/messages`, {
                    signal: controller.signal
                });
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const result = await response.json();
                
                if (result.success) {
                    await displayMessagesIncremental(result.messages);
                    // Reset connection health indicator
                    updateConnectionStatus(true);
                } else {
                    throw new Error(result.error || 'Unknown server error');
                }
            } catch (error) {
                console.error('Failed to load messages:', error);
                updateConnectionStatus(false);
                
                // Exponential backoff retry for network errors
                if (retries > 0 && (error.name === 'AbortError' || error.message.includes('fetch'))) {
                    const delay = Math.pow(2, 3 - retries) * 1000; // 1s, 2s, 4s
                    setTimeout(() => loadMessages(retries - 1), delay);
                }
            }
        }
        
        // Connection status indicator
        function updateConnectionStatus(isConnected) {
            const statusElement = document.querySelector('.status-indicator span');
            if (!statusElement) return;
            
            if (isConnected) {
                statusElement.textContent = 'E2E';
                statusElement.style.color = '#10b981';
            } else {
                statusElement.textContent = '⚠️ Reconnecting...';
                statusElement.style.color = '#f59e0b';
            }
        }

        // Incremental Message Display (prevents flashing)
        async function displayMessagesIncremental(messages) {
            const container = document.getElementById('messagesContainer');
            
            // Create content-based message ID for proper deduplication
            const getContentId = (msg, decryptedText = null) => {
                // Use sender + decrypted content + approximate time for deduplication
                const timeWindow = Math.floor(msg.timestamp / 5000) * 5000; // 5s window
                return `${msg.sender}-${decryptedText || 'encrypted'}-${timeWindow}`;
            };
            
            // Track which messages are new
            const newMessages = [];
            for (const msg of messages) {
                try {
                    // Try to decrypt to get content-based ID
                    const decrypted = await decryptMessage(msg.encryptedData, msg.keyData, currentRoom.id);
                    const contentId = getContentId(msg, decrypted.success ? decrypted.message : null);
                    
                    if (!renderedIds.has(contentId)) {
                        renderedIds.add(contentId);
                        newMessages.push({ ...msg, contentId, decrypted });
                    }
                } catch (error) {
                    // Fallback to timestamp-based ID for undecryptable messages
                    const fallbackId = `${msg.timestamp}-${msg.sender}-${msg.encryptedData.substring(0, 20)}`;
                    if (!renderedIds.has(fallbackId)) {
                        renderedIds.add(fallbackId);
                        newMessages.push({ ...msg, contentId: fallbackId, decrypted: { success: false } });
                    }
                }
            }
            
            // Remove any optimistic messages that match the real messages
            for (const msg of newMessages) {
                // Remove optimistic messages for the same content
                const optimisticToRemove = [];
                for (const [optimisticId, element] of optimisticMessages.entries()) {
                    const optimisticContent = element.querySelector('.message-content')?.textContent;
                    const realContent = msg.decrypted.success ? msg.decrypted.message : null;
                    
                    if (optimisticContent && realContent && optimisticContent.trim() === realContent.trim() && 
                        element.querySelector('.message-header span')?.textContent === msg.sender) {
                        optimisticToRemove.push(optimisticId);
                        element.remove();
                    }
                }
                optimisticToRemove.forEach(id => optimisticMessages.delete(id));
            }
            
            // Only render new messages
            for (const msg of newMessages) {
                await renderSingleMessage(msg, container, msg.decrypted);
            }
            
            // Auto-scroll only if user is near bottom (UX best practice)
            const isNearBottom = container.scrollTop + container.clientHeight >= container.scrollHeight - 50;
            if (isNearBottom && newMessages.length > 0) {
                container.scrollTop = container.scrollHeight;
            }
        }
        
        // Render a single message element
        async function renderSingleMessage(msg, container, preDecrypted = null) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${msg.sender === currentUser ? 'own' : ''}`;
            messageDiv.dataset.msgId = msg.contentId || `${msg.timestamp}-${msg.sender}`;
            
            // Use pre-decrypted content if available (from incremental display)
            const decrypted = preDecrypted || await decryptMessage(msg.encryptedData, msg.keyData, currentRoom.id);
            
            if (decrypted.success) {
                messageDiv.innerHTML = `
                    <div class="message-header">
                        <span>${escapeHtml(msg.sender)}</span>
                        <div>
                            <span class="encryption-badge">EMRLD</span>
                            <span class="text-muted">
                                ${new Date(msg.timestamp).toLocaleTimeString()}
                            </span>
                        </div>
                    </div>
                    <div class="message-content">${escapeHtml(decrypted.message)}</div>
                `;
            } else {
                // Show encrypted message if decryption fails
                messageDiv.className += ' message-encrypted';
                messageDiv.innerHTML = `
                    <div class="message-header">
                        <span>${escapeHtml(msg.sender)}</span>
                        <div>
                            <span class="encryption-badge encrypted">ENCRYPTED</span>
                            <span class="text-error">
                                ${new Date(msg.timestamp).toLocaleTimeString()}
                            </span>
                        </div>
                    </div>
                    <div class="message-content">🔒 ${msg.encryptedData.substring(0, 100)}...</div>
                `;
            }
            
            container.appendChild(messageDiv);
        }

        // Message Refresh
        function refreshMessages() {
            loadMessages();
        }

        // Polling for new messages
        function startPolling() {
            if (messagePolling) clearInterval(messagePolling);
            // Polling interval - aligns with MESSAGE_POLL_INTERVAL in wrangler.toml
            messagePolling = setInterval(loadMessages, 3000); // Poll every 3 seconds
        }

        // Status Display
        function showStatus(message, type) {
            const statusDiv = document.getElementById('setupStatus');
            const statusElement = document.createElement('div');
            statusElement.className = `status ${type === 'success' ? 'success' : 'error'}`;
            statusElement.textContent = message;
            statusDiv.innerHTML = '';
            statusDiv.appendChild(statusElement);
            setTimeout(() => statusDiv.innerHTML = '', 6000);
        }

        // Utility Functions
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Decryption function (matches the worker implementation)
        async function decryptMessage(encryptedDataB64, keyDataB64, context = 'default') {
            try {
                const encryptedData = base64ToArrayBuffer(encryptedDataB64);
                const quantumKey = base64ToArrayBuffer(keyDataB64);
                
                const aesData = xorWithKey(new Uint8Array(encryptedData), new Uint8Array(quantumKey));
                
                let data = aesData;
                const rounds = 3;
                
                for (let i = rounds - 1; i >= 0; i--) {
                    const roundKey = await deriveKey(context + i, `round-${i}`);
                    const iv = data.slice(0, 12);
                    const encrypted = data.slice(12);
                    
                    const decrypted = await crypto.subtle.decrypt(
                        { name: 'AES-GCM', iv },
                        roundKey,
                        encrypted
                    );
                    
                    data = new Uint8Array(decrypted);
                }
                
                const message = new TextDecoder().decode(data);
                return { success: true, message };
            } catch (error) {
                return { success: false, error: error.message };
            }
        }

        // Cryptographic utility functions
        async function deriveKey(password, salt) {
            const keyMaterial = await crypto.subtle.importKey(
                'raw',
                new TextEncoder().encode(password),
                'PBKDF2',
                false,
                ['deriveKey']
            );
            
            return crypto.subtle.deriveKey(
                {
                    name: 'PBKDF2',
                    salt: new TextEncoder().encode(salt),
                    iterations: 10000,
                    hash: 'SHA-256'
                },
                keyMaterial,
                { name: 'AES-GCM', length: 256 },
                true,
                ['encrypt', 'decrypt']
            );
        }

        function xorWithKey(data, key) {
            const result = new Uint8Array(data.length);
            for (let i = 0; i < data.length; i++) {
                result[i] = data[i] ^ key[i % key.length];
            }
            return result;
        }

        function base64ToArrayBuffer(base64) {
            const binary = atob(base64);
            const bytes = new Uint8Array(binary.length);
            for (let i = 0; i < binary.length; i++) {
                bytes[i] = binary.charCodeAt(i);
            }
            return bytes.buffer;
        }

        // Initialize app when DOM is ready
        document.addEventListener('DOMContentLoaded', initializeApp);
        
        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (messagePolling) {
                clearInterval(messagePolling);
            }
        });
    </script>

    <!-- Turnstile Script with deterministic initialization -->
    <script>
        let tsVisibleWidgetId = null;

        function onTSLoaded() {
            try {
                console.log(`Turnstile loaded. Rendering visible widget with sitekey: ${TS_SITEKEY}`);

                // Clean and render the visible widget programmatically
                const visibleElement = document.getElementById('ts-visible');
                if (visibleElement && !tsVisibleWidgetId) {
                    // Clear any stray text content
                    visibleElement.innerHTML = '';

                    tsVisibleWidgetId = turnstile.render('#ts-visible', {
                        sitekey: TS_SITEKEY,
                        theme: 'auto',
                        callback: window.onFirstVerify
                    });
                    console.log('Visible Turnstile widget rendered, ID:', tsVisibleWidgetId);
                }
            } catch(error) {
                console.error('Turnstile onload error:', error);
            }
        }

        // Legacy callback for compatibility
        window.onloadTurnstileCallback = onTSLoaded;
    </script>
    <script src="https://challenges.cloudflare.com/turnstile/v0/api.js?onload=onTSLoaded" async defer></script>


    <noscript>
      <div class="error-message noscript-message">
        JavaScript is required to run Turnstile and use this app.
      </div>
    </noscript>
</body>
</html>
